<html>
<head>
    <style>
        table td:nth-child(1) { font-family: monospace; white-space: pre; padding-right: 2em; font-size: 123.1%; }
    </style>
</head>
<body>

<h1>Neutron Specification v1.0</h1>

<p>Neutron is a binary serialization format to represent complex and nested entities. The top level entity is a document, an entity composed by zero or more key-value pairs.</p>
<p>The format is designed so that data is encoded in a similar way as it is in memory for little-endian processors. Thus, minimal processing is required to encode and decode the data. This also enables the use of zero copying techniques.</p>
<p>The following grammar specifies version 1.1 of the Neutron standard. The grammar is written using a pseudo-BNF syntax. Valid Neutron data is represented by the document non-terminal.</p>

<h2>Basic Types</h2>

<p>The following basic types are used as terminals in the rest of the grammar. Each type must be serialized in little-endian format.</p>

<table>
    <thead>
        <tr><th>Type</th><th>Default</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td>int8</td>   <td>0</td>  <td>1 byte (8-bits signed)</td></tr>
        <tr><td>uint8</td>  <td>0</td>  <td>1 byte (8-bits unsigned)</td></tr>
        <tr><td>int32</td>  <td>0</td>   <td>4 bytes (32-bit signed integer, two's complement)</td></tr>
        <tr><td>uint32</td> <td>0</td>    <td>4 bytes (32-bit unsigned integer)</td></tr>
        <tr><td>int64</td>  <td>0</td>   <td>8 bytes (64-bit signed integer, two's complement)</td></tr>
        <tr><td>uint64</td> <td>&plusmn;0.0</td>    <td>8 bytes (64-bit unsigned integer)</td></tr>
        <tr><td>double</td> <td>&plusmn;0.0</td>    <td>8 bytes (64-bit IEEE 754-2008 binary floating point)</td></tr>
    </tbody>
</table>

<h2>Non-terminals</h2>

<p>The following specifies the rest of the Neutron grammar. Quoted strings represent terminals, and should be interpreted with C semantics (e.g. "\x01" represents the byte 0000 0001). The * symbol is a shorthand for repetition (e.g. ("\x01"*2) means "\x01\x01"). When used as a suffix, * means that the repetition can occur 0 or more times.</p>

<table>
    <tbody>
        <tr><td>document  ::=    size count16 uid (field*)</td> <td>Document with <i>count16</i> fields (up to 2<sup>16</sup>). The entire document occupies <i>size</i> bytes (except the <i>size</i> itself). The <i>uid</i> is an unique identifier for the document layout.</td></tr>
        <tr><td>size      ::=    uint32</td>                     <td>Size in bytes.</td></tr>
        <tr><td>count16   ::=    uint16</td>                     <td>Number of entities (e.g elements, values).</td></tr>
        <tr><td>count32   ::=    uint32</td>                     <td>Number of entities (e.g elements, values).</td></tr>
        <tr><td>field     ::=</td>                               <td>Document field. A document cannot have multiple fields with the same identifier. Fields are serialized in the same order they are specified in the document layout.</td></tr>
        <tr><td>            |    "\x01" pad uid document</td>    <td>Embedded document.</td></tr>
        <tr><td>            |    arrtyp pad uid array</td>       <td>Single-type array.</td></tr>
        <tr><td>            |    "\x03" pad uid binary</td>      <td>Binary data.</td></tr>
        <tr><td>            |    "\x04" pad uid int64</td>       <td>UTC datetime as milliseconds since the Unix epoch.</td></tr>
        <tr><td>            |    "\x05" pad uid float</td>       <td>IEEE 754 32-bit floating point.</td></tr>
        <tr><td>            |    "\x06" pad uid double</td>      <td>IEEE 754 64-bit floating point.</td></tr>
        <tr><td>            |    "\x07" pad uid string</td>      <td>UTF-8 string.</td></tr>
        <tr><td>            |    "\x08" uint8 uid</td>           <td>Boolean. The <i>uint8</i> is set with 0 for false and 1 for true.</td></tr>
        <tr><td>            |    "\x0B" pad uid int32</td>       <td>32-bit integer.</td></tr>
        <tr><td>            |    "\x0C" pad uid uint32</td>      <td>32-bit unsigned integer.</td></tr>
        <tr><td>            |    "\x0D" pad uid int64</td>       <td>64-bit integer.</td></tr>
        <tr><td>            |    "\x0E" pad uid uint64</td>      <td>64-bit unsigned integer.</td></tr>
        <tr><td>            |    "\x4B" int8  uid</td>           <td>32-bit integer with small value (stored in <i>int8</i>).</td></tr>
        <tr><td>            |    "\x4C" uint8 uid</td>           <td>32-bit unsigned integer with small value (stored in <i>uint8</i>).</td></tr>
        <tr><td>            |    "\x4D" int8  uid</td>           <td>64-bit integer with small value (stored in <i>int8</i>).</td></tr>
        <tr><td>            |    "\x4E" uint8 uid</td>           <td>64-bit unsigned integer with small value (stored in <i>uint8</i>).</td></tr>
        <tr><td>pad       ::=    uint8</td>                      <td>Padding.</td></tr>
        <tr><td>uid       ::=    uint16</td>                     <td>Unique field identifier.</td></tr>
        <tr><td>string    ::=    size (uint8*)</td>              <td>UTF-8 string with <i>size</i> bytes. The <i>(uint8*)</i> is zero or more UTF-8 encoded characters, padded with zeros to align to 4 bytes.</td></tr>
        <tr><td>array     ::=    size count32 (uint8*)</td>      <td>Single-type array with <i>count32</i> entries. The entire array occupies <i>size</i> bytes. The <i>(uint8*)</i> is the array content, padded with zeros to align to 4 bytes. The padding is considered in <i>size</i> but not in <i>count32</i>.</td></tr>
        <tr><td>arrtyp    ::=</td>                               <td>Array type. These are the same terminals used for document field types, but with the most significant bit set.</td></tr>
        <tr><td>            |    "\x81"</td>                     <td>Embedded document.</td></tr>
        <tr><td>            |    "\x83"</td>                     <td>Binary data.</td></tr>
        <tr><td>            |    "\x84"</td>                     <td>UTC datetime as milliseconds since the Unix epoch.</td></tr>
        <tr><td>            |    "\x85"</td>                     <td>IEEE 754 32-bit floating point.</td></tr>
        <tr><td>            |    "\x86"</td>                     <td>IEEE 754 64-bit floating point.</td></tr>
        <tr><td>            |    "\x87"</td>                     <td>UTF-8 string.</td></tr>
        <tr><td>            |    "\x88"</td>                     <td>Boolean (0 for false and 1 for true).</td></tr>
        <tr><td>            |    "\x8B"</td>                     <td>32-bit integer.</td></tr>
        <tr><td>            |    "\x8C"</td>                     <td>32-bit unsigned integer.</td></tr>
        <tr><td>            |    "\x8D"</td>                     <td>64-bit integer.</td></tr>
        <tr><td>            |    "\x8E"</td>                     <td>64-bit unsigned integer.</td></tr>
        <tr><td>binary    ::=    size (byte*)</td>               <td>Generic binary data.</td></tr>
    </tbody>
</table>

<h2>Optimization</h2>
<p>Fields of <a href="#basic_types">basic types</a> containing the default value <i>might</i> be ignored during serialization to reduce the output size. Fields of other data types <i>might</i> also be ignored if they meet the conditions in the following table.</p>

<table>
    <thead>
        <tr><th>Field type</th><th>Condition to ignore field</th></tr>
    </thead>
    <tbody>
        <tr><td>document</td>     <td>Document has no fields or all of its fields were ignored.</td></tr>
        <tr><td>array</td>     <td>Number of elements in the array is zero.</td></tr>
        <tr><td>binary</td>     <td>Binary data is empty (i.e. size is zero).</td></tr>
    </tbody>
</table>

<p>Notice that a field with type <i>document</i> might be ignored but the root document is always present, even if all of its fields were ignored.</p>

<h2>Examples</h2>



</body>
</html>